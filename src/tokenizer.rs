/// A token info is a definition of a token type which can be generated 
/// by a tokenizer.
///
/// The generic type E is an enum which list token type. An instance of TokenInfo
/// is a description of one of the item of E. 
pub struct TokenInfo<E>
{
    /// The type of the item as listed in the enum E.
    token_type: E,

    /// The regex which define the form of this token.
    regex:      String,
}

impl<E> TokenInfo<E>
{
    pub fn new(typeT: E, reg: &String) -> TokenInfo<E>
    {
        TokenInfo{
            token_type: typeT,
            regex: reg.clone(),
        }
    }
}

/// This structure is initialized with the types of token to extract.
///
/// We can then use the function parse to split any given string in token
/// according to the description of the token types provided at the 
/// initialization of the struct.
///
/// The generic type E is an enum which list of the types of token that can be
/// generated by this instance of tokenizer.
pub struct Tokenizer<E>
{
    /// This vector contain the definition of the differents type of token
    /// that can be generated by this tokenizer.
    types_info: Vec<TokenInfo<E>>,
}

impl<E> Tokenizer<E>
{
    pub fn new(infos: Vec<TokenInfo<E>>) -> Tokenizer<E>
    {
        Tokenizer{
            types_info: infos,
        }
    }

    /// This function will take the string to_parse and return the list of 
    /// token corresponding to it.
    pub fn parse(to_parse: &String) -> Vec<Token<E>>
    {
    }
}

#[test]
fn test_tokenizer()
{
    let token_types = vec![
        TokenInfo::new(TokenType::NUMBER, &"[0-1]+.?[0-1]+".to_string()),
    ];
    Tokenizer::new(token_types);
}
